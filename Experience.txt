回溯算法:
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，
这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

1. 递归调用需要强化
    a. 链表操作常用递归操作，递归参数通常为下一次操作的头指针，如RandomPointer
    b. 生成所有可能组合，例子：GenerateParentheses，ConcatenateWords（生成所有的单词排列组合），LetterCombination
    c. 可以在所有组合中寻找符合条件的例子，如CombinationSum
2. 移动指针遍历
    a. 两个链表同一个循环遍历，只要有一个链表没有遍历结束则继续，如AddTwoNumbers
    b. 一次移动一步指针匹配相应字符，LongestPalindromicSubstring，ConcatenateWords（找匹配的组合字串），LongestSubstringWithoutRepeatingCharacters
3. 双指针

4. Hash表
    a. 寻找匹配的数字，最好的办法是存到Hash表中，而不是一遍一遍的遍历，如TwoSum，ConcatenateWords（从Hash表中匹配是否是要查找的单词）
    b. 统计出现的次数用Hash也是很好的办法。
5. 绝妙算法
    a. NextPermutation：找到下一个稍大一点的数，注意寻找相对有序子列，需要把一眼能看出的东西转换成算法
    b.
6. 二分法
    a. 在要求时间复杂度为O(logn)时或一个有序数组，一般使用二分法。一个局部有序的数组，会弄出很多花招，如RotatedSortedArray
    b. 使用二分法查找也可以不匹配相等的，也可以匹配大于或者小于某个数，如FirstLastElementPositionInSortedArray
7. 回溯算法
    a. 回溯算法跟递归调用一起使用可以生成所有各种组合。如ConcatenateWords，CombinationSum，CombinationSumII，SudokuSolver1
    b. 生成的组合可以通过使用条件，Hash表等按题目要求生成重复，非重复，唯一等结果。
        i. ConcatenateWords，给出重复单词生成所有可能的组合。使用Hash表避免同一个单词被使用多次，使用跳重条件
           (i > 0 && words[i] == words[i - 1])，避免重复单词造成多余相同组合。
        ii. CombinationSum，组合中允许同一个元素/数多次出现的时候，可以把循环的Start Index指定为上一个递归调用的循环的Index本身
        iii. CombinationSumII，组合中不允许同一个元素/数出现多次的时候，可以把循环的Start Index指定为上一个递归调用循环的Index + 1
8. 链表操作
    a. 链表头经过变换后发生变化的，一般会在最前面加一个虚头，以便记录头指针。

    由买卖股票展开的
    连续三道使用动态规划解决买卖股票的题，这里谈谈对它们的理解，加深自己的印象和认知，能帮到其他朋友就更好了。俗话说知易行难，但这几道题的概念理解上也不容易。
    从第一道只做一锤子买卖开始。(题121)
    首先是定义dp数组，dp[i][0]表示第i天如果购买股票后手里所剩现金。这个定义注意两点。第一，这是一个可能值，因为如果在后面发现有使用更低价格买入的话，那么当前值就可能被抛弃，但谁知道后面会怎样，先姑且把值记在这里吧。第二，这是剩下的现金，假设有100元，买了7元的股票，还剩93元。现在这个券商很大方，允许零资产贷款买股票，买了7元股票，手上的资产就成了-7元了。
    dp[i][1]表示第i天如果把手中股票卖掉后手里的现金。这道题隐含了一点，因为最初手里的现金为0，所以最后手里的现金就是交易完成后最大的利润。
    接下来，定义公式，为了说明以[7,1,5,3,6,4]为例。第一个公式，dp[i][0] = max(dp[i - 1][0], -prices[i])。这个公式容易理解，就是从一系列价格中找最低的买入价让自己手上所剩现金最多。第一天是价格是7元，如果买了手上还剩-7元。第二天价格跌到了1元，反悔了，第一天的交易不作数，今天重新买入，手上还剩-1元。反复比较就是找到一系列价格中的最小值。
    第二个公式，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])。卖出股票手里的现金是买入股票后手上的现金与当前股票的价格和。如果这个和比之前获得的利润少，则不交易。在买入后发现后面有更高的价格，反悔，以更高的价格卖掉获取最高利润。
    第二道，反复买低卖高(题714)
    dp[i][0]和dp[i][1]的定义不变。这次可以反复交易，手里的现金通过多次交易进行积累。在第二次买入后的现金是第一次卖出后手上的现金减去买入股票的花费。这样就实现了现金的积累。
    第三道，最多只能交易两次
    dp[i][0]:一次操作也没有时的手上现金；
    dp[i][1]:第一次买入股票手上所剩最大现金；
    dp[i][2]:第一次卖出股票手上所剩最大现金；
    dp[i][3]:第二次卖出股票手上所剩最大现金；
    dp[i][2]:第二次卖出股票手上所剩最大现金；

一. 类型
1. 数组
   a. 二分法：闭区间[left, right]和半开区间[left, right)的区别。闭区间使用left <= right，left = mid + 1或right = mid - 1。 半开区间是 left < right，left = mid + 1和right = mid。
       i. 关于二分法第二种情况(闭开区间)的详细解释参考，https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/
       ii. 二分法题集：704(基本二分法)，33(在旋转数组中搜索指定值)，153(在旋转数组中搜索最小值)。注：旋转数组能使用二分法是因为分段有序。
       iii. 二分法甚至能在没有排序的数组中使用，找局部最大值，题162。
       iv. 二分法在不能直接找到期望的结果，既完全相等的结果时，最终会找到一个最接近期望结果的值，这时使用left，题275， 题278
       v. 万能的二分法，在有序或局部有序的数组中，二分法要首先考虑。二分的参考值可能是一个简单的值，也可能是一个计算值，题378。
   b. 双指针：
       i. 使用快慢两个指针，一般用于数组里面元素的移动，快指针正常遍历，并把快指针的数据移到慢指针。(题27)
       ii. 在求三数和的时候，先排序再固定一个数，然后用双指针从两端向中间移动。（题15，题18）
       iii. 在使用双指针移除数组，链表中元素时，到底是从前往后移动还是从后往前移动，要从时间复杂度具体分析。
       iv. 双指针除了同步移动之外，可以在让一个指针用while循环移动满足要求为止。题455。
   c. 滑动窗口：类似双指针，但是是用来统计两个指针之间的数据，像是窗口一样。(题209)
   d. 在数组遍历中，用while循环按要求跳过中间项，有利于简化问题。(题228)
   e. 在数组中求众数，使用摩尔投票法达到时间O(n)和空间O(1)的要求。(题229)
   d. 在求数组其余数字的积时，通过两次遍历，把当前位置左边和右边的积分别求出，然后再拼到一起。(题238)
   e. 求在数组中是否含有递增三个数，使用low, mid完成，关键思路是在碰到比前一个low的数时，用其更新low，同样也可能更新mid，并找到比mid大的数则完成搜索。题334。
   f. 求两个数组的交集，先把两个数组排序，然后比较两个数组中元素的大小，碰到相等这记录。题349，题350。
2. 链表
   a. 链表反转：分四步。第一步，按正序保存下一个节点（next=cur.next);第二步，把当前节点的后续指向上一个节点（cur.next=pre);第三步，当前节点变成上一个节点（pre=cur);最后，下一个节点变成当前节点（cur=next)
   b. 虚拟表头：在链表操作中有可能原表头元素会因满足某条件删除，在这种情况下，可以在原表头前添加一个虚拟表头，是处理统一。
   c. 双指针：链表里面也有很多地方使用双指针，环形链表找入环第一个节点，
       i. 比如删掉倒数第n个节点（19题），让Fast指针先移动n个节点，然后Slow指针跟着一起移动，直到快指针移动到末尾。
       ii. 求交点节点（如https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/），从剩余长度相等处时开始搜索。
       iii. 同样用快慢指针在环中相遇，然后从head和慢指针同时移动直到再相遇。(题142)
       iv. 找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动2步，慢指针每次移动1步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。
       v. 题234是快慢指针(求链表的一半)，链表的反转的一个综合应用。
3. 字符串
   a. 在数组或字符串遍历的时候，遍历的顺序可以不用是i++一个一个遍历，可以根据题意把遍历的步长变为k/2k，(题541)
   b. 反转字符串中的单词（单词的顺序翻转，而单词里面的字母顺序不翻转），如从"the sky is blue"到"blue is sky the"。使用的技巧是整个字符串翻转，在每个单词翻转。题151。
        i. 反转的反转能解决数组旋转的问题，题189。
   c. 在字符串中匹配相同的子串，使用HashSet能减少逐字的匹配达到提高效率的目的，题187。

4. 栈与队列
   a. 在队列中维护滑动窗口最大值得下标，题239
   b. 使用优先队列维护按某种顺序排列的前n个值，题347
5. 树
   a. 遍历顺序：树的先序，中序，后序遍历各自特点。
       i. 中序遍历常用在二叉搜索树中
       ii. 后序遍历的特点是从树的叶节点自下往上开始搜索，可以用来查最近的公共祖先(题236)
       iii. 注意前序遍历生成的先后顺序和右子树后序遍历一致(114题)，而后序遍历和右子树前序遍历一致。
       iv. 保存上一个节点有助于在二叉树遍历中让问题简单。在二叉搜索树中使用中序遍历，上一个节点是已遍历节点中值最大的，可以用来验证是不是一个二叉搜索树（98题）。在改变二叉树节点关系时候，后序遍历把上一个节点置为当前节点的右孩子。
   b. 层序遍历的迭代算法。
       i. 树的深度。注意：如果使用递归调用算深度，在返回子树的深度时在加上本节点的深度，既加上1。
   c. 树的生成、翻转，让递归函数返回节点，并把节点赋值给左右子树可以简化代码。
   d. Java中的红黑树TreeSet，既能按对象增删，也能按值排序，实际是按二叉搜索树记性排序，其floor和ceiling函数，题220。
   e. 根据中-后遍序序列或前-中序列构造二叉树其实就是用的分治思想，在前或后序列中先找到根节点，然后把前中或中后分割成左右子树的序列进行递归。题106，题654。
   f. 在修剪树的时候，使用返回树节点方法进行去除节点。例如把当前节点的左节点或右节点返回给父节点，就相当于把当前节点去除。题450，题669。
6. 回溯
   a. 回溯算法的减枝值，如果一个集合里面没有一个元素，则i<=n-k+1，n-(n-k)=k，所以i最少需要从n-k+1开始，题77。
   b. 回溯的两种形式，一种是深度优先(使用for循环和start)，一种是广度优先(使用二叉树的概念和level)。
   c. 回溯中，如果有相同的数字或字符，但不能包含重复的组合，要使用排序去重，题40。
   d. 使用回溯取不同长度的子字符串，注意取法，题131，题93。
   e. 求子集，貌似复杂，其实简单到了极点，经过的组合不用进行任何判断，都加入结果集，题78。
   //f. 在使用二叉树回溯的时候，需要去重，需要判断上次的值，如果当前值等于上次值则略过后面的组合，因为这种重复值出现一次的的组合都已经尝试过了，题40。(有缺陷）
   g. 有重复数字的全排列，剪枝条件为"if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue"，!used[i - 1]表示在前面的排列中[i - 1]这个数已经使用过，如果再出现[i]这个数，将出现重复排列。
   h. 题437的回溯算法跟一般的不太一样，循环是按四条边循环，递归使用火柴的index。
7. 贪心算法
   a. 需要考虑两个维度的题，先考虑一个维度再考虑另一个维度，两个维度同事考虑的话，会顾此失彼。题135，分别从两边遍历得到结果；题406先考虑身高，再考虑人数。
   b. 遇到数组的时候尝试排序，可能有助于问题解决。
   c. 题968，用后序遍历从叶节点开始搜索，然后巧妙设置节点状态。
7. 动态规划
   a. 动态规划的递推公式f[i]可能与前一个f[i-1]有关，也可能仅跟当前元素nums[i]有关，需要根据题意使用Min或Max进行比较。(题53，题152)
   b. 动态规划的结果可能直接在f[length]中获取，也可能需要遍历f[0]-f[length],需要根据f[i]的定义来决定。需要遍历f[i]的如题152， 题120。
   c. 拆分数的动态规划，递推公式很巧，不容易联想到跟前面的数的最大值联系在起来。题343。
   d. 分段、分左右的递推公式，使用前面的f[i]相乘得到递推公式。题96。
   e. 0-1背包，如果使用滚动数组的变化
       i. 把数组的物品维度压缩，但循环还是两重，既物品数量和背包容量。所有递推公式是f[j]=max(f[j],f[j-w[i]]+v[i])。(i表示物品，j表示容量)
       ii. 背包容量的遍历顺序是倒序，既for(int j = bagWeight; j >= weight[i]; j--)
       iii. 要具有逆向思维，求一堆石头两两粉粹最后剩多重的石头，方法是平分成两堆，再求差。题1049。同样使用逆向思维的是题435，先找出最大不重叠区间，然后得到需要移除的最少区间。
       iv. 两个维度的0-1背包，题474。

   f. 完全背包，注意完全背包和0-1背包在概念上的差别，以及其循环和0-1背包的滚动数组的循环差别。for(int j = weight[i]; j < bagWeight; j++)
       i. 使用安全平方数组合求规定和，题279。难点是要自己算可能使用的数。
       ii. 使用完全排列背包解决单词拆分，注意两点，一是怎么取词，二是设置f[i]的意义。
       iii. 完全背包的排列组合注意两重遍历的顺序。分别把0-1背包的组合，完全背包的组合和排列的循环列在下面
       0-1
       dp[0] = 1;
       for (int i = 0; i < nums.length; i++) {
           for (int j = size; j >= nums[i]; j--) { //从后往前遍历
               dp[j] += dp[j - nums[i]];
           }
       }
       完全背包组合
       dp[0] = 1;
       for (int i = 0; i < coins.length; i++) {
           for (int j = coins[i]; j <= amount; j++) { //从前往后遍历
               dp[j] += dp[j - coins[i]];
           }
       }
       完全背包排列
       dp[0] = 1;
       for (int i = 0; i <= target; i++) {
           for (int j = 0; j < nums.length; j++) {
               if (i >= nums[j]) {
                   dp[i] += dp[i - nums[j]];
               }
           }
       }
   g. 打家劫舍
       i. 经典打家劫舍的公式：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])，题198。
       ii. 成环的大家劫舍，掐头去尾按经典打家劫舍分别计算，最后比较大小，题213。
       iii. 树形结构的动态规划，声明长度为2的数组，下标为0记录不选该节点所得到的的最大值，下标为1记录选该节点所得到的的最大值，题337。
   h. 股票
       i. 一次交易，题121
          首先是定义dp数组，dp[i][0]表示第i天如果购买股票后手里所剩现金。这个定义注意两点。第一，这是一个可能值，因为如果在后面发现有使用更低价格买入的话，那么当前值就可能被抛弃，但谁知道后面会怎样，先姑且把值记在这里吧。第二，这是剩下的现金，假设有100元，买了7元的股票，还剩93元。现在这个券商很大方，允许零资产贷款买股票，买了7元股票，手上的资产就成了-7元了。
          dp[i][1]表示第i天如果把手中股票卖掉后手里的现金。这道题隐含了一点，因为最初手里的现金为0，所以最后手里的现金就是交易完成后最大的利润。
          接下来，定义公式，为了说明以[7,1,5,3,6,4]为例。第一个公式，dp[i][0] = max(dp[i - 1][0], -prices[i])。这个公式容易理解，就是从一系列价格中找最低的买入价让自己手上所剩现金最多。第一天是价格是7元，如果买了手上还剩-7元。第二天价格跌到了1元，反悔了，第一天的交易不作数，今天重新买入，手上还剩-1元。反复比较就是找到一系列价格中的最小值。
          第二个公式，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])。卖出股票手里的现金是买入股票后手上的现金与当前股票的价格和。如果这个和比之前获得的利润少，则不交易。在买入后发现后面有更高的价格，反悔，以更高的价格卖掉获取最高利润。
       ii. 多次交易，题122
       iii. 两次交易，题123
           dp[i][0]:一次操作也没有时的手上现金；
           dp[i][1]:第一次买入股票手上所剩最大现金；
           dp[i][2]:第一次卖出股票手上所剩最大现金；
           dp[i][3]:第二次卖出股票手上所剩最大现金；
           dp[i][4]:第二次卖出股票手上所剩最大现金；
       iv. 冷冻期，题309。在持股，不持股之间再增加一个冻结状态。
       v. 含手续费，题714。在买股票的时候把手续费考虑进去。

   i. 子序列
       i. 最长递增子序列：使用两重循环确定以每个元素截至的最长子序列，注意初始化。题300。
       ii.最长连续递增子序列：使用一重循环，当前大于前面则在前面的计数上加一，同样注意初始化。题674。
       iii. 最长重复子数组：注意子数组和子序列的定义的不同之处，子数组是连续的，子序列是可以不连续。同样是两重循环分别对两个数组中的元素进行两两比较，相等则计数加一。题718。
       iv. 最长公共子序列：题1143。
       v. 不相交的线：跟最长公共子序列是完全的题。题1035。
       vi. 最大子序和：前面通过动态规划的值如果为负，在当前计算的时候则不计入，则生成了动态规划的递推公式。题53。
       vii. 判读子序列：判断字符串S是否为字符串T的一个子序列。这个其实是最长公共子序列的一种极端情况，第一个字符串退化为每个字符都是公共子序列的情况。在这种情况下在不等的情况下，递推公式由f[i][j]=max(f[i][j-1], f[i-1][j])退化为f[i][j]=f[i][j-1]，因为f[i][j-1]肯定不会比f[i-1][j]小，S字符串的每个字符都是公共字符串的一部分，多一个公共字符的长度值肯定不比少一个小。题392。
       viii. 不同的子序列：这道题最难理解的是递推公式怎么处理在几个相同的字符之间选或者不选，同时在两个字符相等的情况下为什么还要加dp[i - 1][j](f[i - 1][j - 1] + f[i - 1][j])。注意这个求的组合数。题115。

   注：动态规划就是以空间换时间把前面计算的结果保存下来，后续的计算以前面的为基础。
9. 矩阵(二维数组)圈围图形
   a. 找到入口点，从入口点出发把关联点设置成有助于判断的值，题200，题130
10. 图
   a. 求欧拉路径，Hierrholzer算法，题332
        Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：
            i. 从起点出发，进行深度优先搜索。
            ii. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。
            iii. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。



698.划分为k个相等的子集
473.火柴拼正方形

二. 算法
1. 桶
   a. 关于桶的概念和怎么分桶，参考https://leetcode-cn.com/problems/contains-duplicate-iii/solution/c-li-yong-tong-fen-zu-xiang-xi-jie-shi-b-ofj6/
   b. 题220。
2. 分治算法
   a. 大问题可以分解为同类型若干小问题，然后再合并。典型例题，合并排序
   b. 题242。这道题除了使用分治算法，还有列举所有组合的思想。
   c. 题395。分段找出符合的解。
3. 线段树
   a. 关于线段树的概念，参考https://leetcode-cn.com/problems/range-sum-query-mutable/solution/qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-leetcode/
   b. 题307。
4. 摩尔投票法
   a. 关于摩尔投票法，参考https://leetcode-cn.com/problems/majority-element-ii/solution/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh/
   b. 题169，题229。
5. 快速排序/选择
   a. 题215。
6. 位运算
   a. 判断是不是2的n次方，n&(n-1) == 0，如果为0，则是2的n次方。
   b.





