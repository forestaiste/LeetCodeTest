回溯算法:
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，
这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

1. 递归调用需要强化
    a. 链表操作常用递归操作，递归参数通常为下一次操作的头指针，如RandomPointer
    b. 生成所有可能组合，例子：GenerateParentheses，ConcatenateWords（生成所有的单词排列组合），LetterCombination
    c. 可以在所有组合中寻找符合条件的例子，如CombinationSum
2. 移动指针遍历
    a. 两个链表同一个循环遍历，只要有一个链表没有遍历结束则继续，如AddTwoNumbers
    b. 一次移动一步指针匹配相应字符，LongestPalindromicSubstring，ConcatenateWords（找匹配的组合字串），LongestSubstringWithoutRepeatingCharacters
3. 双指针

4. Hash表
    a. 寻找匹配的数字，最好的办法是存到Hash表中，而不是一遍一遍的遍历，如TwoSum，ConcatenateWords（从Hash表中匹配是否是要查找的单词）
    b. 统计出现的次数用Hash也是很好的办法。
5. 绝妙算法
    a. NextPermutation：找到下一个稍大一点的数，注意寻找相对有序子列，需要把一眼能看出的东西转换成算法
    b.
6. 二分法
    a. 在要求时间复杂度为O(logn)时或一个有序数组，一般使用二分法。一个局部有序的数组，会弄出很多花招，如RotatedSortedArray
    b. 使用二分法查找也可以不匹配相等的，也可以匹配大于或者小于某个数，如FirstLastElementPositionInSortedArray
7. 回溯算法
    a. 回溯算法跟递归调用一起使用可以生成所有各种组合。如ConcatenateWords，CombinationSum，CombinationSumII，SudokuSolver1
    b. 生成的组合可以通过使用条件，Hash表等按题目要求生成重复，非重复，唯一等结果。
        i. ConcatenateWords，给出重复单词生成所有可能的组合。使用Hash表避免同一个单词被使用多次，使用跳重条件
           (i > 0 && words[i] == words[i - 1])，避免重复单词造成多余相同组合。
        ii. CombinationSum，组合中允许同一个元素/数多次出现的时候，可以把循环的Start Index指定为上一个递归调用的循环的Index本身
        iii. CombinationSumII，组合中不允许同一个元素/数出现多次的时候，可以把循环的Start Index指定为上一个递归调用循环的Index + 1
8. 链表操作
    a. 链表头经过变换后发生变化的，一般会在最前面加一个虚头，以便记录头指针。