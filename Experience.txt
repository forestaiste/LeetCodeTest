回溯算法:
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，
这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

1. 递归调用需要强化
    a. 链表操作常用递归操作，递归参数通常为下一次操作的头指针，如RandomPointer
    b. 生成所有可能组合，例子：GenerateParentheses，ConcatenateWords（生成所有的单词排列组合），LetterCombination
    c. 可以在所有组合中寻找符合条件的例子，如CombinationSum
2. 移动指针遍历
    a. 两个链表同一个循环遍历，只要有一个链表没有遍历结束则继续，如AddTwoNumbers
    b. 一次移动一步指针匹配相应字符，LongestPalindromicSubstring，ConcatenateWords（找匹配的组合字串），LongestSubstringWithoutRepeatingCharacters
3. 双指针

4. Hash表
    a. 寻找匹配的数字，最好的办法是存到Hash表中，而不是一遍一遍的遍历，如TwoSum，ConcatenateWords（从Hash表中匹配是否是要查找的单词）
    b. 统计出现的次数用Hash也是很好的办法。
5. 绝妙算法
    a. NextPermutation：找到下一个稍大一点的数，注意寻找相对有序子列，需要把一眼能看出的东西转换成算法
    b.
6. 二分法
    a. 在要求时间复杂度为O(logn)时或一个有序数组，一般使用二分法。一个局部有序的数组，会弄出很多花招，如RotatedSortedArray
    b. 使用二分法查找也可以不匹配相等的，也可以匹配大于或者小于某个数，如FirstLastElementPositionInSortedArray
7. 回溯算法
    a. 回溯算法跟递归调用一起使用可以生成所有各种组合。如ConcatenateWords，CombinationSum，CombinationSumII，SudokuSolver1
    b. 生成的组合可以通过使用条件，Hash表等按题目要求生成重复，非重复，唯一等结果。
        i. ConcatenateWords，给出重复单词生成所有可能的组合。使用Hash表避免同一个单词被使用多次，使用跳重条件
           (i > 0 && words[i] == words[i - 1])，避免重复单词造成多余相同组合。
        ii. CombinationSum，组合中允许同一个元素/数多次出现的时候，可以把循环的Start Index指定为上一个递归调用的循环的Index本身
        iii. CombinationSumII，组合中不允许同一个元素/数出现多次的时候，可以把循环的Start Index指定为上一个递归调用循环的Index + 1
8. 链表操作
    a. 链表头经过变换后发生变化的，一般会在最前面加一个虚头，以便记录头指针。

    由买卖股票展开的
    连续三道使用动态规划解决买卖股票的题，这里谈谈对它们的理解，加深自己的印象和认知，能帮到其他朋友就更好了。俗话说知易行难，但这几道题的概念理解上也不容易。
    从第一道只做一锤子买卖开始。(题121)
    首先是定义dp数组，dp[i][0]表示第i天如果购买股票后手里所剩现金。这个定义注意两点。第一，这是一个可能值，因为如果在后面发现有使用更低价格买入的话，那么当前值就可能被抛弃，但谁知道后面会怎样，先姑且把值记在这里吧。第二，这是剩下的现金，假设有100元，买了7元的股票，还剩93元。现在这个券商很大方，允许零资产贷款买股票，买了7元股票，手上的资产就成了-7元了。
    dp[i][1]表示第i天如果把手中股票卖掉后手里的现金。这道题隐含了一点，因为最初手里的现金为0，所以最后手里的现金就是交易完成后最大的利润。
    接下来，定义公式，为了说明以[7,1,5,3,6,4]为例。第一个公式，dp[i][0] = max(dp[i - 1][0], -prices[i])。这个公式容易理解，就是从一系列价格中找最低的买入价让自己手上所剩现金最多。第一天是价格是7元，如果买了手上还剩-7元。第二天价格跌到了1元，反悔了，第一天的交易不作数，今天重新买入，手上还剩-1元。反复比较就是找到一系列价格中的最小值。
    第二个公式，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])。卖出股票手里的现金是买入股票后手上的现金与当前股票的价格和。如果这个和比之前获得的利润少，则不交易。在买入后发现后面有更高的价格，反悔，以更高的价格卖掉获取最高利润。
    第二道，反复买低卖高(题714)
    dp[i][0]和dp[i][1]的定义不变。这次可以反复交易，手里的现金通过多次交易进行积累。在第二次买入后的现金是第一次卖出后手上的现金减去买入股票的花费。这样就实现了现金的积累。
    第三道，最多只能交易两次
    dp[i][0]:一次操作也没有时的手上现金；
    dp[i][1]:第一次买入股票手上所剩最大现金；
    dp[i][2]:第一次卖出股票手上所剩最大现金；
    dp[i][3]:第二次卖出股票手上所剩最大现金；
    dp[i][2]:第二次卖出股票手上所剩最大现金；

一. 类型
1. 数组
   a. 二分法：闭区间[left, right]和半开区间[left, right)的区别。闭区间使用left <= right，left = mid + 1或right = mid - 1。 半开区间是 left < right，left = mid + 1和right = mid。
       注：很多题只是寻找跳变的位置，而不需要有相等结果返回，使用二分法就会找到这个跳变位置。
       i. 关于二分法第二种情况(闭开区间)的详细解释参考，https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/
       ii. 二分法题集：704(基本二分法)，33(在旋转数组中搜索指定值)，153(在旋转数组中搜索最小值)。注：旋转数组能使用二分法是因为分段有序。
       iii. 二分法如果不用等式来找特定的值，只有大于和小于的判断，那么会找到一个最接近期望值得值。题34。
       iv. 二分法在不能直接找到期望的结果，既完全相等的结果时，最终会找到一个最接近期望结果的值，这时使用left，题275， 题278
       v. 二分法甚至能在没有排序的数组中使用，找局部最大值，题162。
       vi. 万能的二分法，在有序或局部有序的数组中，二分法要首先考虑。二分的参考值可能是一个简单的值，也可能是一个计算值，题378。
       vii. 二分法求平方根，题69。
       viii. 发现有序的标杆为二分法创造条件，题287。此题和378类似，都是找一个需要计算出来的有序值。
       ix. 验证一个数是不是完全平方数，题367。
   b. 双指针：
       i. 使用快慢两个指针，一般用于数组里面元素的移动，快指针正常遍历，并把快指针的数据移到慢指针。(题26, 题27)
       ii. 在求三数和的时候，先排序再固定一个数，然后用双指针从两端向中间移动。（题15，题18）
       iii. 在使用双指针移除数组，链表中元素时，到底是从前往后移动还是从后往前移动，要从时间复杂度具体分析。
       iv. 双指针除了同步移动之外，可以在让一个指针用while循环移动满足要求为止。题455。
       v. 删除有序数组中的重复项中的，快慢指针使用起来比较难理解，题80。
   c. 滑动窗口：类似双指针，但是是用来统计两个指针之间的数据，像是窗口一样。(题209, 题3)
   d. 在数组遍历中，用while循环按要求跳过中间项，有利于简化问题。(题228)
   e. 在数组中求众数，使用摩尔投票法达到时间O(n)和空间O(1)的要求。(题229)
   d. 在求数组其余数字的积时，通过两次遍历，把当前位置左边和右边的积分别求出，然后再拼到一起。(题238)
   e. 求在数组中是否含有递增三个数，使用low, mid完成，关键思路是在碰到比前一个low的数时，用其更新low，同样也可能更新mid，并找到比mid大的数则完成搜索。题334。
   f. 求两个数组的交集，先把两个数组排序，然后比较两个数组中元素的大小，碰到相等这记录。题349，题350。
   g. 找到下一个排列，从数组末尾开始搜索，在后缀中找到第一个破坏降序的数，然后重新从末尾开始搜索，找到第一个比破坏降序的那个数大的数，换位，最后把后缀反序。
2. 链表
   a. 链表反转：分四步。第一步，按正序保存下一个节点（next=cur.next);第二步，把当前节点的后续指向上一个节点（cur.next=pre);第三步，当前节点变成上一个节点（pre=cur);最后，下一个节点变成当前节点（cur=next)
   b. 虚拟表头：在链表操作中有可能原表头元素会因满足某条件删除，在这种情况下，可以在原表头前添加一个虚拟表头，是处理统一。
   c. 双指针：链表里面也有很多地方使用双指针，环形链表找入环第一个节点，
       i. 比如删掉倒数第n个节点（19题），让Fast指针先移动n个节点，然后Slow指针跟着一起移动，直到快指针移动到末尾。
       ii. 求交点节点（如https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/），从剩余长度相等处时开始搜索。
       iii. 同样用快慢指针在环中相遇，然后从head和慢指针同时移动直到再相遇。(题142)
       iv. 找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动2步，慢指针每次移动1步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。
       v. 题234是快慢指针(求链表的一半)，链表的反转的一个综合应用。
       vi. 环形链表，141，142。
       vii. 快慢指针用来寻找链表的中点，题145。
   d. 链表排序的两种方法
       i. 插入排序： 双重循环，复杂度O(n2)，题147
       ii. 分治归并排序：相当于二分排序，复杂度O(nlogn)，题148
3. 字符串
   a. 在数组或字符串遍历的时候，遍历的顺序可以不用是i++一个一个遍历，可以根据题意把遍历的步长变为k/2k，(题541)
   b. 反转字符串中的单词（单词的顺序翻转，而单词里面的字母顺序不翻转），如从"the sky is blue"到"blue is sky the"。使用的技巧是整个字符串翻转，在每个单词翻转。题151。
        i. 反转的反转能解决数组旋转的问题，题189。"hello world"翻转成"world hello"跟数组"1234567"旋转成"5671234"是一样的。
        ii. integer的bit反转走位移的方法，注意不要掉到上面的陷阱了。题190。
   c. 在字符串中匹配相同的子串，使用HashSet能减少逐字的匹配达到提高效率的目的，题187。

4. 栈与队列
   a. 在队列中维护滑动窗口最大值得下标，题239
   b. 使用优先队列维护按某种顺序排列的前n个值，题347
   c. 使用栈实现基本计算，这道题解法的巧妙在于把所有操作数都放进堆栈且全部转换为加法，则在堆栈里面就没有保存操作符号，而乘除法是第一遍就得到结果。
5. 树
   a. 遍历顺序：树的先序，中序，后序遍历各自特点。
       i. 中序遍历常用在二叉搜索树中, 利用二叉搜索树的顺序特性把有序链表转换成二叉搜索树。题109。
       ii. 后序遍历的特点是从树的叶节点自下往上开始搜索，可以用来查最近的公共祖先(题236)
       iii. 注意前序遍历生成的先后顺序和右子树后序遍历一致(114题)，而后序遍历和右子树前序遍历一致。
       iv. 保存上一个节点有助于在二叉树遍历中让问题简单。在二叉搜索树中使用中序遍历，上一个节点是已遍历节点中值最大的，可以用来验证是不是一个二叉搜索树（98题）。在改变二叉树节点关系时候，后序遍历把上一个节点置为当前节点的右孩子。
   b. 层序遍历的迭代算法。
       i. 树的深度。注意：如果使用递归调用算深度，在返回子树的深度时在加上本节点的深度，既加上1。
   c. 树的生成、翻转，让递归函数返回节点，并把节点赋值给左右子树可以简化代码。
   d. Java中的红黑树TreeSet，既能按对象增删，也能按值排序，实际是按二叉搜索树记性排序，其floor和ceiling函数，题220。
   e. 根据中-后遍序序列或前-中序列构造二叉树其实就是用的分治思想，在前或后序列中先找到根节点，然后把前中或中后分割成左右子树的序列进行递归。题106，题654。
   f. 在修剪树的时候，使用返回树节点方法进行去除节点。例如把当前节点的左节点或右节点返回给父节点，就相当于把当前节点去除。题450，题669。
6. 回溯
   a. 回溯算法的减枝值，如果一个集合里面没有一个元素，则i<=n-k+1，n-(n-k)=k，所以i最少需要从n-k+1开始，题77。
   b. 回溯的两种形式，一种是深度优先(使用for循环和start)，一种是广度优先(使用二叉树的概念和level)。
   c. 回溯中，如果有相同的数字或字符，但不能包含重复的组合，要使用排序去重，题40。
   d. 使用回溯取不同长度的子字符串，注意取法，题131，题93，题306。
      注：这类分割不同字符串的有一重循环，然后使用start(递归传递的值)和循环的i来分割字符串。
   e. 求子集，貌似复杂，其实简单到了极点，经过的组合不用进行任何判断，都加入结果集，题78。
   //f. 在使用二叉树回溯的时候，需要去重，需要判断上次的值，如果当前值等于上次值则略过后面的组合，因为这种重复值出现一次的的组合都已经尝试过了，题40。(有缺陷）
   g. 有重复数字的全排列，剪枝条件为"if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue"，!used[i - 1]表示在前面的排列中[i - 1]这个数已经使用过，如果再出现[i]这个数，将出现重复排列。
   h. 题437的回溯算法跟一般的不太一样，循环是按四条边循环，递归使用火柴的index。
   i. 题22，题113，题129的回溯算法也很特别，可以对比一下
   j. 怎在没有使用额外参数的情况下，保证每一个数没用到且没用被重用，题474.
7. 贪心算法
   a. 需要考虑两个维度的题，先考虑一个维度再考虑另一个维度，两个维度同事考虑的话，会顾此失彼。题135，分别从两边遍历得到结果；题406先考虑身高，再考虑人数。
   b. 遇到数组的时候尝试排序，可能有助于问题解决。
   c. 题968，用后序遍历从叶节点开始搜索，然后巧妙设置节点状态。
8. 动态规划
   a. 动态规划的递推公式f[i]可能与前一个f[i-1]有关，也可能仅跟当前元素nums[i]有关，需要根据题意使用Min或Max进行比较。(题53，题152)
   b. 动态规划的结果可能直接在f[length]中获取，也可能需要遍历f[0]-f[length],需要根据f[i]的定义来决定。需要遍历f[i]的如题152， 题120。
   c. 拆分数的动态规划，递推公式很巧，不容易联想到跟前面的数的最大值联系在起来。题343。
   d. 分段、分左右的递推公式，使用前面的f[i]相乘得到递推公式。题96。
   e. 0-1背包，如果使用滚动数组的变化
       i. 把数组的物品维度压缩，但循环还是两重，既物品数量和背包容量。所有递推公式是f[j]=max(f[j],f[j-w[i]]+v[i])。(i表示物品，j表示容量)
       ii. 背包容量的遍历顺序是倒序，既for(int j = bagWeight; j >= weight[i]; j--)
       iii. 要具有逆向思维，求一堆石头两两粉粹最后剩多重的石头，方法是平分成两堆，再求差。题1049。同样使用逆向思维的是题435，先找出最大不重叠区间，然后得到需要移除的最少区间。
       iv. 两个维度的0-1背包，题474。

   f. 完全背包，注意完全背包和0-1背包在概念上的差别，以及其循环和0-1背包的滚动数组的循环差别。for(int j = weight[i]; j < bagWeight; j++)
       i. 使用安全平方数组合求规定和，题279。难点是要自己算可能使用的数。
       ii. 使用完全排列背包解决单词拆分，注意两点，一是怎么取词，二是设置f[i]的意义。
       iii. 完全背包的排列组合注意两重遍历的顺序。分别把0-1背包的组合，完全背包的组合和排列的循环列在下面
       0-1
       如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；
       dp[0] = 1;
       for (int i = 0; i < nums.length; i++) {
           for (int j = target; j >= nums[i]; j--) { //从后往前遍历
               dp[j] += dp[j - nums[i]];
           }
       }

       0-1背包求值类问题，递推公式：f[j] = max(f[j - 1], f[j - nums[i]] + nums[i]])
       0-1背包求组合类问题，递推公式：f[j] += f[j - nums[i]]或f[j] = f[j] + f[j - nums[i]]

       完全背包组合
       如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。
       dp[0] = 1;
       for (int i = 0; i < nums.length; i++) {
           for (int j = nums[i]; j <= target; j++) { //从前往后遍历
               dp[j] += dp[j - nums[i]];
           }
       }
       完全背包排列
       如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。
       dp[0] = 1;
       for (int i = 0; i <= target; i++) {
           for (int j = 0; j < nums.length; j++) {
               if (i >= nums[j]) {
                   dp[i] += dp[i - nums[j]];
               }
           }
       }
   g. 打家劫舍
       i. 经典打家劫舍的公式：dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])，题198。
       ii. 成环的大家劫舍，掐头去尾按经典打家劫舍分别计算，最后比较大小，题213。
       iii. 树形结构的动态规划，声明长度为2的数组，下标为0记录不选该节点所得到的的最大值，下标为1记录选该节点所得到的的最大值，题337。
   h. 股票
       i. 一次交易，题121
          首先是定义dp数组，dp[i][0]表示第i天如果购买股票后手里所剩现金。这个定义注意两点。第一，这是一个可能值，因为如果在后面发现有使用更低价格买入的话，那么当前值就可能被抛弃，但谁知道后面会怎样，先姑且把值记在这里吧。第二，这是剩下的现金，假设有100元，买了7元的股票，还剩93元。现在这个券商很大方，允许零资产贷款买股票，买了7元股票，手上的资产就成了-7元了。
          dp[i][1]表示第i天如果把手中股票卖掉后手里的现金。这道题隐含了一点，因为最初手里的现金为0，所以最后手里的现金就是交易完成后最大的利润。
          接下来，定义公式，为了说明以[7,1,5,3,6,4]为例。第一个公式，dp[i][0] = max(dp[i - 1][0], -prices[i])。这个公式容易理解，就是从一系列价格中找最低的买入价让自己手上所剩现金最多。第一天是价格是7元，如果买了手上还剩-7元。第二天价格跌到了1元，反悔了，第一天的交易不作数，今天重新买入，手上还剩-1元。反复比较就是找到一系列价格中的最小值。
          第二个公式，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])。卖出股票手里的现金是买入股票后手上的现金与当前股票的价格和。如果这个和比之前获得的利润少，则不交易。在买入后发现后面有更高的价格，反悔，以更高的价格卖掉获取最高利润。
       ii. 多次交易，题122
       iii. 两次交易，题123
           dp[i][0]:一次操作也没有时的手上现金；
           dp[i][1]:第一次买入股票手上所剩最大现金；
           dp[i][2]:第一次卖出股票手上所剩最大现金；
           dp[i][3]:第二次卖出股票手上所剩最大现金；
           dp[i][4]:第二次卖出股票手上所剩最大现金；
       iv. 冷冻期，题309。在持股，不持股之间再增加一个冻结状态。
       v. 含手续费，题714。在买股票的时候把手续费考虑进去。
   i. 子序列
       i. 最长递增子序列：使用两重循环确定以每个元素截至的最长子序列，注意初始化。题300。
       ii.最长连续递增子序列：使用一重循环，当前大于前面则在前面的计数上加一，同样注意初始化。题674。
       iii. 最长重复子数组：注意子数组和子序列的定义的不同之处，子数组是连续的，子序列是可以不连续。同样是两重循环分别对两个数组中的元素进行两两比较，相等则计数加一。题718。
       iv. 最长公共子序列：题1143。
       v. 不相交的线：跟最长公共子序列是完全的题。题1035。
       vi. 最大子序和：前面通过动态规划的值如果为负，在当前计算的时候则不计入，则生成了动态规划的递推公式。题53。
       vii. 判断子序列：判断字符串S是否为字符串T的一个子序列。这个其实是最长公共子序列的一种极端情况，第一个字符串退化为每个字符都是公共子序列的情况。在这种情况下在不等的情况下，递推公式由f[i][j]=max(f[i][j-1], f[i-1][j])退化为f[i][j]=f[i][j-1]，如果按照原max的递推公式也可以得到结果。使用递推公式的时候是把s看成一个整体，f[i][j]表示要完全匹配s的0到i-1个字符。题392。
       viii. 不同的子序列：这道题最难理解的是递推公式怎么处理在几个相同的字符之间选或者不选，同时在两个字符相等的情况下为什么还要加dp[i - 1][j](f[i - 1][j - 1] + f[i - 1][j])。注意这个求的组合数。题115。
             这道题的解释看https://leetcode-cn.com/problems/distinct-subsequences/solution/dong-tai-gui-hua-yi-ci-ti-wei-li-jiang-j-enq0/
       ix. 两个字符串的删除操作：这道题难理解的是删除也是从1开始遍历到末尾。题583。
       x.
       注1：在子序列题目中，如果求的是连续子序列f[i][j]则只跟f[i-1][j-1]有关，如果求子序列f[i][j]不但和f[i-1][j-1]有关还和f[i][j-1]以及f[i-1][j]有关。
       注2：动态规划就是以空间换时间把前面计算的结果保存下来，后续的计算以前面的为基础。
   j. 回文
       i. 递推公式的推导，遍历的顺序。在设计f[i][j]究竟是表示值还是Bool类型的时候，注意值是否能方便的表示出来。题647。题516。
   k. 其他动态规划
       i. 题91。注意字母组合的计算方法。
       ii. 题120。
       iii. 题139。
       iv. 题153。
       v. 题221。这道题是设法f[i][j]为包含1的正方形边长的最大值。这个很巧。
       vi. 题264。
       vii. 题279。
       viii. 题322。
       ix. 题338。
       x. 题343。f[i -1]本身就包含了前面之前的结果，这个结果是可以应用的。
       xi. 题368。跟题300类似，两重循环两两比较。比题300难一点是需要找到这个子集。
       xii. 题375。最难的动态规划。
       xiii. 题1409。


9. 矩阵(二维数组)圈围图形
   a. 旋转图像，注意旋转对应方格的坐标，然后只需要遍历左上角的1/4，题48。
   b. 旋转矩阵，注意循环条件，left, right, top, bottom的更新时机，题54。
   c. 矩阵置零，把中间的0往第一列和第一行转移，题73。
   d. 找到入口点，从入口点出发把关联点设置成有助于判断的值，题200，题130
   e. 单词搜索，使用回溯和方向组合解决问题。题79。
   f. 二维矩阵搜索
       i. 每行中的整数从左到右按升序排列，每行的第一个整数大于前一行的最后一个整数，使用两次二分法，题74。
       ii. 每行的元素从左到右升序排列，每列的元素从上到下升序排列，


10. 图
   a. 拓扑排序，题207, 题310。
   b. 出度入度，题331
   c. 求欧拉路径，Hierrholzer算法，题332
        Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：
            i. 从起点出发，进行深度优先搜索。
            ii. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。
            iii. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。
   注：深度优先的搜索算法会最先击破不能再维持深度搜索的节点，既在那个节点或者因为条件不满足不能进行递归调用了。因为没有递归则直接返回，那么第二个返回的是调用第一个节点的，以此类推。




二. 算法
1. 桶
   a. 关于桶的概念和怎么分桶，参考https://leetcode-cn.com/problems/contains-duplicate-iii/solution/c-li-yong-tong-fen-zu-xiang-xi-jie-shi-b-ofj6/
   b. 题220。
2. 分治算法
   a. 大问题可以分解为同类型若干小问题，然后再合并。典型例题，合并排序
   b. 题241。这道题除了使用分治算法，还有列举所有组合的思想。注意分治算法和回溯算法的区别。
   c. 题395。分段找出符合的解。
   d. 题23，注意是怎么分的，然后怎么合的，算法是怎么做的。
   e. 题395。
3. 线段树
   a. 关于线段树的概念，参考https://leetcode-cn.com/problems/range-sum-query-mutable/solution/qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-leetcode/
   b. 题307。
4. 摩尔投票法
   a. 关于摩尔投票法，参考https://leetcode-cn.com/problems/majority-element-ii/solution/liang-fu-dong-hua-yan-shi-mo-er-tou-piao-fa-zui-zh/
   b. 题169，题229。
5. 快速排序/选择
   a. 题215。
6. 位运算
   a. 判断是不是2的n次方，n&(n-1) == 0，如果为0，则是2的n次方。题231。
        i. 判断是不是4的幂。4的幂必定是2的幂。去除掉仅为2的幂部分。
   b. 异或的性质：任何数和0异或，结果为原数；任何数与自身异或都为0；异或满足交换律和结合律。题136，题260，题268。
       i. 题260分组是按两个数某个不一样的bit把所有的数分成两组。
       ii. 题268把所有的数再异或一遍。
   c. Integer的Bit反转使用位移的方法。
   d. 使用移位寻找两个数的公共前端，题201。
   e. 用字母把一个4位Integer相应的位置位，并按位与。题318。
   f. 使用位运算，求和。使用异或、与以及移位。题371。
7. KMP算法
   a. 题28
8. 深拷贝
   a. 题133，题138都是用Hash表作为是否已经访问的依据。
9. Hash表
   a. 记字符串，题187。
   b. 双向Hash，题205，题290。
   c. 散列表，题219。
   d. 让Hash的值表示不同的状态或者来源。题299。
   e. 把Hash的结果作为PriorityQueue的比较依据。题347。
   f. Hash表很难想到的应用，454。
10. 数学类
   a. 各位相加，题258。
   b. Nim，题292。
   c. 灯泡开关，题319。统计在n之前的完全平方数。
   d. 贝祖定理，题365。
   e. 求超大数的n次幂的mod，题372。
   f. 题392。

三. 难题集
* 1. 题23。注意是怎么分的，然后怎么合的，算法是怎么做的。
* 2. 题91。判断合法字母的判断条件。
* 3. 题93。判断IP地址段合法的判断条件。
* 4. 题95。分治加递归，跟在分治上题96有相似之处。
* 5. 题97。在字符匹配上的算法，以及初始化
* 6. 题128。使用HashSet,两次循环，从HashSet的最小数字中找连续。
* 7. 题135。从两个方向分别考虑，其实相等于另一种动态规划。
** 8. 题152。这道题和题53类似，53是求最大子序和，这道是求最大子序积，思路类似。但这道还要考虑负数的影响，所以需要两个状态，一个为正，另一个为负。
9. 题153。二分法的和哪个数比较。
10. 题162。在从左向右循环时只比较nums[i] > nums[i +1]，时隐含了nums[i] < nums[i +1]，显然在轮询到一下个数的时候num[i - 1] < nums[i]。
11. 题172。算5的个数。
12. 题179。寻找的是拼接后最大的数，那么排序按两两拼接进行比较排序。
13. 题207。拓扑排序。
14. 题215。快速排序加二分逼近思想。
15. 题220。桶。
16. 题229。摩尔投票法。
17. 题238。两次遍历，分别准备左边累计的乘积和右边累计乘积，然后求解。跟题135分发糖果类似。
18. 题241。分治合并算法。
19. 题258。
20. 题279。
21. 题287!!!!
22. 题310。
23. 题316。统计每个字母在字符串里出现的次数，如果追加的字母比前一个字母小且前一个字母后面还有则删除。明显分两步走。第一步，统计次数。第二步，追加字母。
24. 题318。分两步走，第一次统计每个单词的位值，比较位值。
25. 题331。
26. 题332。
27. 题334。
28. 题338。
29. 题343。
30. 题378。
31. 题435。排序的标准。
32. 题450。
33. 题454。Hash表的应用
34. 题473。回溯算法，注意怎么保证每个数没用到且没有重复使用。
35. 题738。

四. 综合
1. 题155。最小栈，另外创建一个栈，把当前最小值压栈，可能会连续多个都是压的某个值。
2. 题173。按中序遍历，按顺序存储到List中。
3. 题211。前缀树
4. 题307。线段树
5. 题341。混合型转扁平化
6. 题380。List和Map的综合应用
7. 题384。使用两个数组，一个保存原数组，一个保存打乱后。





