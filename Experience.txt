回溯算法:
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，
这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

1. 递归调用需要强化
    a. 链表操作常用递归操作，递归参数通常为下一次操作的头指针，如RandomPointer
    b. 生成所有可能组合，例子：GenerateParentheses，ConcatenateWords（生成所有的单词排列组合），LetterCombination
    c. 可以在所有组合中寻找符合条件的例子，如CombinationSum
2. 移动指针遍历
    a. 两个链表同一个循环遍历，只要有一个链表没有遍历结束则继续，如AddTwoNumbers
    b. 一次移动一步指针匹配相应字符，LongestPalindromicSubstring，ConcatenateWords（找匹配的组合字串），LongestSubstringWithoutRepeatingCharacters
3. 双指针

4. Hash表
    a. 寻找匹配的数字，最好的办法是存到Hash表中，而不是一遍一遍的遍历，如TwoSum，ConcatenateWords（从Hash表中匹配是否是要查找的单词）
    b. 统计出现的次数用Hash也是很好的办法。
5. 绝妙算法
    a. NextPermutation：找到下一个稍大一点的数，注意寻找相对有序子列，需要把一眼能看出的东西转换成算法
    b.
6. 二分法
    a. 在要求时间复杂度为O(logn)时或一个有序数组，一般使用二分法。一个局部有序的数组，会弄出很多花招，如RotatedSortedArray
    b. 使用二分法查找也可以不匹配相等的，也可以匹配大于或者小于某个数，如FirstLastElementPositionInSortedArray
7. 回溯算法
    a. 回溯算法跟递归调用一起使用可以生成所有各种组合。如ConcatenateWords，CombinationSum，CombinationSumII，SudokuSolver1
    b. 生成的组合可以通过使用条件，Hash表等按题目要求生成重复，非重复，唯一等结果。
        i. ConcatenateWords，给出重复单词生成所有可能的组合。使用Hash表避免同一个单词被使用多次，使用跳重条件
           (i > 0 && words[i] == words[i - 1])，避免重复单词造成多余相同组合。
        ii. CombinationSum，组合中允许同一个元素/数多次出现的时候，可以把循环的Start Index指定为上一个递归调用的循环的Index本身
        iii. CombinationSumII，组合中不允许同一个元素/数出现多次的时候，可以把循环的Start Index指定为上一个递归调用循环的Index + 1
8. 链表操作
    a. 链表头经过变换后发生变化的，一般会在最前面加一个虚头，以便记录头指针。

    由买卖股票展开的
    连续三道使用动态规划解决买卖股票的题，这里谈谈对它们的理解，加深自己的印象和认知，能帮到其他朋友就更好了。俗话说知易行难，但这几道题的概念理解上也不容易。
    从第一道只做一锤子买卖开始。
    首先是定义dp数组，dp[i][0]表示第i天如果购买股票后手里所剩现金。这个定义注意两点。第一，这是一个可能值，因为如果在后面发现有使用更低价格买入的话，那么当前值就可能被抛弃，但谁知道后面会怎样，先姑且把值记在这里吧。第二，这是剩下的现金，假设有100元，买了7元的股票，还剩93元。现在这个券商很大方，允许零资产贷款买股票，买了7元股票，手上的资产就成了-7元了。
    dp[i][1]表示第i天如果把手中股票卖掉后手里的现金。这道题隐含了一点，因为最初手里的现金为0，所以最后手里的现金就是交易完成后最大的利润。
    接下来，定义公式，为了说明以[7,1,5,3,6,4]为例。第一个公式，dp[i][0] = max(dp[i - 1][0], -prices[i])。这个公式容易理解，就是从一系列价格中找最低的买入价让自己手上所剩现金最多。第一天是价格是7元，如果买了手上还剩-7元。第二天价格跌到了1元，反悔了，第一天的交易不作数，今天重新买入，手上还剩-1元。反复比较就是找到一系列价格中的最小值。
    第二个公式，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])。卖出股票手里的现金是买入股票后手上的现金与当前股票的价格和。如果这个和比之前获得的利润少，则不交易。在买入后发现后面有更高的价格，反悔，以更高的价格卖掉获取最高利润。
    第二道，反复买低卖高
    dp[i][0]和dp[i][1]的定义不变。这次可以反复交易，手里的现金通过多次交易进行积累。在第二次买入后的现金是第一次卖出后手上的现金减去买入股票的花费。这样就实现了现金的积累。
    第三道，最多只能交易两次
    dp[i][0]:一次操作也没有时的手上现金；
    dp[i][1]:第一次买入股票手上所剩最大现金；
    dp[i][2]:第一次卖出股票手上所剩最大现金；
    dp[i][3]:第二次卖出股票手上所剩最大现金；
    dp[i][2]:第二次卖出股票手上所剩最大现金；

 1. 数组
    a. 二分法：闭区间[left, right]和半开区间[left, right)的区别。闭区间使用left <= right，left = mid + 1或right = mid - 1。 半开区间是 left < right，left = mid + 1和right = mid。
    b. 双指针：使用快慢两个指针，一般用于数组里面元素的移动，快指针正常遍历，并把快指针的数据移到慢指针。
        i. 在求三数和的时候，先排序再固定一个数，然后用双指针从两端向中间移动。（题15，题18）
    c. 滑动窗口：类似双指针，但是是用来统计两个指针之间的数据，像是窗口一样。
 2. 链表
    a. 链表反转：分四步。第一步，按正序保存下一个节点（next=cur.next);第二步，把当前节点的后续指向上一个节点（cur.next=pre);第三步，当前节点变成上一个节点（pre=cur);最后，下一个节点变成当前节点（cur=next)
    b. 虚拟表头：在链表操作中有可能原表头元素会因满足某条件删除，在这种情况下，可以在原表头前添加一个虚拟表头，是处理统一。
    c. 双指针：链表里面也有很多地方使用双指针，比如删掉倒数第n个节点（19题），让Fast指针先移动n个节点，然后Slow指针跟着一起移动，直到快指针移动到末尾。求交点节点（如https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/），从剩余长度相等处时开始搜索。环形链表找入环第一个节点，同样用快慢指针在环中相遇，然后从head和慢指针同时移动直到再相遇。
 3. 树
    a. 遍历顺序：树的先序，中序，后序遍历各自特点。
        i. 中序遍历常用在二叉搜索树中
        ii. 后序遍历的特点是从树的叶节点自下往上开始搜索
        iii. 注意前序遍历生成的先后顺序和右子树后序遍历一致（114题），二后序遍历和右子树前序遍历一致。
        iv. 保存上一个节点有助于在二叉树遍历中让问题简单。在二叉搜索树中使用中序遍历，上一个节点是已遍历节点中值最大的，可以用来验证是不是一个二叉搜索树（98题）。在改变二叉树节点关系时候，后序遍历把上一个节点置为当前节点的右孩子。
        





